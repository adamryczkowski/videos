# Strict shell for all recipes
set shell := ["bash", "-euo", "pipefail", "-c"]

# Default help
[private]
help:
    just --list

# Ensure pipx is available (user-local, no sudo)
[private]
install-pipx:
    #!/usr/bin/env bash
    set -euo pipefail
    if command -v pipx >/dev/null 2>&1; then
      exit 0
    fi
    python3 -m pip install --user pipx
    python3 -m pipx ensurepath 2>/dev/null || pipx ensurepath || true

# Install a tool via pipx if not present
[private]
install-pipx-dependency name command_name="{{name}}": install-pipx
    #!/usr/bin/env bash
    set -euo pipefail
    if command -v {{ command_name }} >/dev/null 2>&1; then
      exit 0
    fi
    pipx install {{ name }}

# Install Poetry if missing (prefers pipx, falls back to user pip in Docker)
install-poetry:
    #!/usr/bin/env bash
    set -euo pipefail
    if command -v poetry >/dev/null 2>&1; then
      exit 0
    fi
    if [ -f /.dockerenv ] && [ "$(whoami)" != "root" ]; then
      python3 -m pip install --user poetry
      if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
        export PATH="$HOME/.local/bin:$PATH"
      fi
      exit 0
    fi
    just install-pipx-dependency "poetry"

# Install project dependencies inside an in-project venv
[private]
install-deps: install-poetry
    #!/usr/bin/env bash
    set -euo pipefail
    # Load project configuration if present (contains PYTHON_PATH and USE_SPACK)
    # This file is generated by apply-the-template with machine-specific settings
    PYTHON_PATH=""
    USE_SPACK=""
    if [ -f ".project-config" ]; then
      # shellcheck disable=SC1091
      source ./.project-config
    fi
    # If USE_SPACK is set or Spack is available, and spack.yaml exists, ensure env and activate it
    # Note: spack-ensure.sh will install Spack if it's not present, so we check USE_SPACK first
    if [ -f "spack.yaml" ]; then
      if [ "$USE_SPACK" = "true" ] || command -v spack >/dev/null 2>&1; then
        bash ./scripts/spack-ensure.sh
        if [ -f ".spack-activate.sh" ]; then
          # shellcheck disable=SC1091
          source ./.spack-activate.sh
        fi
      fi
    fi
    # Deactivate any foreign venv to avoid confusion with Poetry's .venv
    if [ -n "${VIRTUAL_ENV-}" ]; then
      # deactivate is a shell function, not a command - use type to check
      if type deactivate >/dev/null 2>&1; then
        deactivate || true
      else
        # If deactivate function doesn't exist, just unset VIRTUAL_ENV
        unset VIRTUAL_ENV
      fi
    fi
    # Tell Poetry which Python to use for the virtualenv
    # Priority: PYTHON_PATH from config > Spack view Python > auto-detect
    if [ -n "$PYTHON_PATH" ] && [ -x "$PYTHON_PATH" ]; then
      echo "Configuring Poetry to use specified Python: $PYTHON_PATH"
      poetry env use "$PYTHON_PATH"
    elif [ -x ".spack-env/view/bin/python3" ]; then
      echo "Configuring Poetry to use Spack view Python: .spack-env/view/bin/python3"
      poetry env use .spack-env/view/bin/python3
    fi
    poetry install --with dev,test
    # Patch the venv's activate script to include Spack view bin directory
    # This ensures tools like deno are available when the venv is activated
    if [ -d ".spack-env/view/bin" ]; then
      # Get the venv path from Poetry
      VENV_PATH=$(poetry env info --path 2>/dev/null || echo "")
      if [ -n "$VENV_PATH" ] && [ -f "$VENV_PATH/bin/activate" ]; then
        SPACK_VIEW_BIN="$(pwd)/.spack-env/view/bin"
        if ! grep -q "spack-env/view/bin" "$VENV_PATH/bin/activate"; then
          echo "" >> "$VENV_PATH/bin/activate"
          echo "# Added by just setup: include Spack view bin for tools like deno" >> "$VENV_PATH/bin/activate"
          echo "export PATH=\"$SPACK_VIEW_BIN:\$PATH\"" >> "$VENV_PATH/bin/activate"
        fi
      fi
    fi

# Install pre-commit hooks into .git/hooks (ensures hooks are fetched)
install-hooks: install-deps
    #!/usr/bin/env bash
    set -euo pipefail
    poetry run pre-commit install --install-hooks

# Setup development environment: poetry deps + pre-commit hooks
setup: install-deps install-hooks
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Setup complete."

# Run unit tests with coverage report
test:
    #!/usr/bin/env bash
    set -euo pipefail
    poetry run coverage run -m pytest -q
    poetry run coverage report -m

# Static type checking
typecheck:
    #!/usr/bin/env bash
    set -euo pipefail
    poetry run pyright

# Run formatting hooks (fixers that modify files)
# Shows a line before each formatter and reports only if files were modified.
format: install-deps
    #!/usr/bin/env bash
    set -euo pipefail

    # Helper function to run a formatter with clean output
    run_fmt() {
      local hook_id="$1"
      local extra_args="${2:-}"
      echo "Running $hook_id..."
      local output
      output=$(poetry run pre-commit run "$hook_id" --all-files $extra_args 2>&1) || true
      # Check if hook exists
      if echo "$output" | grep -q "No hook with id"; then
        return 0
      fi
      # Show files that were modified
      if echo "$output" | grep -qE "(Fixing|Fixed|files were modified)"; then
        echo "$output" | grep -E "^Fixing" | head -20 || true
      fi
    }

    echo "==> Running formatting hooks"
    run_fmt end-of-file-fixer
    run_fmt trailing-whitespace
    run_fmt mixed-line-ending
    run_fmt ruff
    run_fmt ruff-format
    run_fmt yamlfix
    run_fmt beautysh
    echo "==> Formatting complete"

# Run all pre-commit hooks on all files (runs format first)
# Fails with non-zero exit code if any hook fails.
validate: format
    #!/usr/bin/env bash
    set -euo pipefail
    echo "==> Running all pre-commit hooks"
    poetry run pre-commit run --all-files

# Update pre-commit hooks to the latest versions
update-pre-commit:
    #!/usr/bin/env bash
    set -euo pipefail
    # Use --freeze to pin to commit hashes and avoid mutable tag warnings
    poetry run pre-commit autoupdate --freeze

# Upgrade all Python dependencies to their latest versions
upgrade-deps:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "==> Upgrading all Python dependencies..."
    poetry update
    echo "==> Dependencies upgraded. Run 'just setup' to reinstall."

# Build wheel package into dist/
package:
    #!/usr/bin/env bash
    set -euo pipefail
    poetry check
    poetry build -f wheel

# Clean build artifacts and temporary files
clean:
    #!/usr/bin/env bash
    set -euo pipefail
    rm -rf build/ dist/ .pytest_cache/ .coverage* htmlcov/ .ruff_cache/ .mypy_cache/
    find . -name "__pycache__" -type d -prune -exec rm -rf {} +

# Build wheel, install into a clean venv, and smoke-test import & version
# Fails if any step fails. See ./scripts/test-package.sh for details.
test-package:
    #!/usr/bin/env bash
    set -euo pipefail
    bash ./scripts/test-package.sh
